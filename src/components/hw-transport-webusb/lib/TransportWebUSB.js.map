{"version":3,"sources":["../src/TransportWebUSB.js"],"names":["configurationValue","interfaceNumber","endpointNumber","TransportWebUSB","device","exchangeBusyPromise","releaseInterface","reset","close","open","configuration","selectConfiguration","claimInterface","message","isSupported","list","listen","observer","unsubscribed","then","deviceModel","productId","next","type","descriptor","complete","error","unsubscribe","channel","Math","floor","random","packetSize","exchange","apdu","exchangeAtomicImpl","debug","toString","framing","blocks","makeBlocks","i","length","transferOut","result","acc","getReducedResult","transferIn","r","reduceResponse","Buffer","from","data","buffer"],"mappings":"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","file":"TransportWebUSB.js","sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport {\n  TransportOpenUserCancelled,\n  TransportInterfaceNotAvailable\n} from \"@ledgerhq/errors\";\nimport { getLedgerDevices, requestLedgerDevice, isSupported } from \"./webusb\";\n\nconst configurationValue = 1;\nconst interfaceNumber = 2;\nconst endpointNumber = 3;\n\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport<USBDevice> {\n  device: USBDevice;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n\n  constructor(device: USBDevice) {\n    super();\n    this.device = device;\n  }\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device that was selected by the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<USBDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    requestLedgerDevice().then(\n      device => {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      error => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n  static async open(device: USBDevice) {\n    await device.open();\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n    await device.reset();\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n    return new TransportWebUSB(device);\n  }\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(interfaceNumber);\n    await this.device.reset();\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { debug, channel, packetSize } = this;\n      if (debug) {\n        debug(\"=>\" + apdu.toString(\"hex\"));\n      }\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        acc = framing.reduceResponse(acc, Buffer.from(r.data.buffer));\n      }\n\n      if (debug) {\n        debug(\"<=\" + result.toString(\"hex\"));\n      }\n      return result;\n    });\n\n  setScrambleKey() {}\n}\n"]}